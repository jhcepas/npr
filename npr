#!/usr/bin/env python
import os
import imp
import logging
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from configobj import ConfigObj, flatten_errors
from validate import Validator

import sys
sys.path.insert(0, "/home/jhuerta/_Devel/ete/2.2/")
from ete_dev import SeqGroup

from master_task import Task
from interface import app_wrapper
from scheduler import schedule

try:
    module_path = os.path.split(__file__)[0]
    __VERSION__ = open(os.path.join(module_path, "VERSION")).read().strip()
except: 
    __VERSION__ = "unknown"

try:
    module_path = os.path.split(__file__)[0]
    __DATE__ = open(os.path.join(module_path, "DATE")).read().strip()
except: 
    __DATE__ = "unknown"

__DESCRIPTION__ = """ 
--------------------------------------------------------------------------------
                 Nested Phylogenetic Reconstruction program.  
                          NPR-0.1%s(alpha), %s.

      @@2:NPR@@1: is a program for phylogenetic reconstruction that optimizes
      the resolution of the final tree by fine grained tunning and
      recomputing of the inner nodes.

      If you use this program for published work, please cite: 

       Jaime Huerta-Cepas and Toni Gabaldon. Nested Phylogenetic
       Reconstruction. XXX-XX. 2011.

      Contact: jhuerta [at] crg.es, tgabaldon [at] crg.es
--------------------------------------------------------------------------------
""" %(__VERSION__, __DATE__)

def main(args):
    log = logging.getLogger("main")

    print __DESCRIPTION__

    configspec = ConfigObj("specs", 
                           list_values=False, _inspec=True)

    config = ConfigObj("config", configspec=configspec)

    val = Validator()
    check = config.validate(val)
    if not check:
        print flatten_errors(config, check)
        raise ValueError("Error reading config file!")

    base_dir = os.path.abspath(config["general"]["basedir"])
    if not os.path.exists(base_dir):
        os.mkdir(base_dir)

    config["general"]["basedir"] = base_dir
    Task.global_config["basedir"] = base_dir
    # Load pipeline
    pipeline_module = config["general"]["pipeline"]
    if os.path.isfile(pipeline_module):
        template = imp.load_module("__main__.standard1", open(pipeline_module),
                                   pipeline_module, ["py", "r", imp.PY_SOURCE])
    else:
        imp.find_module("standard1", __path__)

    # check nt_seed and aa_seed. Do they contain the same seqs?
    # format? names?
    visited_seqs = set()
    seed_files = {}
    for label, seq_file in [["aa_seed", args.aa_seed_file],
                            ["nt_seed", args.nt_seed_file]]:
        if seq_file: 
            seqs = SeqGroup(seq_file)
            for i,n in seqs.id2name.iteritems():
                if len(n)>10: 
                    seqs.id2name[i] = n[:10]
                    log.warning("sequence names %s was truncated to 10 chars: %s " %(n, n[:10]))
            values = seqs.id2name.values()
            if len(values) != len(set(values)):
                raise Exception("Duplicated sequence names, execution aborted.")
            if visited_seqs and set(values) != visited_seqs:
                raise Exception("Sequence names do not match between aa and nt files.")
            visited_seqs.update(values)
            fullpath = os.path.join(base_dir, label+".fasta")
            seed_files[label] = fullpath
            seqs.write(outfile=fullpath)

    config["general"]["aa_seed"] =  seed_files.get("aa_seed", None)
    config["general"]["nt_seed"] =  seed_files.get("nt_seed", None)

    schedule(config, template.pipeline, args.schedule_time, args.execute, args.retry)


if __name__ == "__main__":
    parser = ArgumentParser(description=__DESCRIPTION__, 
                            formatter_class=RawDescriptionHelpFormatter)
    # name or flags - Either a name or a list of option strings, e.g. foo or -f, --foo.
    # action - The basic type of action to be taken when this argument is encountered at the command line. (store, store_const, store_true, store_false, append, append_const, version)
    # nargs - The number of command-line arguments that should be consumed. (N, ? (one or default), * (all 1 or more), + (more than 1) )
    # const - A constant value required by some action and nargs selections. 
    # default - The value produced if the argument is absent from the command line.
    # type - The type to which the command-line argument should be converted.
    # choices - A container of the allowable values for the argument.
    # required - Whether or not the command-line option may be omitted (optionals only).
    # help - A brief description of what the argument does.
    # metavar - A name for the argument in usage messages.
    # dest - The name of the attribute to be added to the object returned by parse_args().

    parser.add_argument("-c", "--config", dest="configfile", 
                        type=str, required=True, 
                        help="""A valid config file to execute the pipeline""")

    parser.add_argument("-a", "--aa-seed-file", dest="aa_seed_file", 
                        type=str, 
                        help="""Initial multi sequence file with protein sequences""")

    parser.add_argument("-n", "--nt-seed-file", dest="nt_seed_file", 
                        type=str, 
                        help="""Initial multi sequence file with nucleotide sequences""")

    parser.add_argument("-t", "--schedule-time", dest="schedule_time", 
                        type=int, default=1,
                        help="""Schedule time in seconds. """)

    parser.add_argument("-r", "--retry-error-jobs", dest="retry", 
                        action="store_true",
                        help="""Try to relaunch jobs marked as error """)

    parser.add_argument("-x", "--execute-inplace", dest="execute", 
                        action="store_true",
                        help="""Jobs are launched in this machine """)

    parser.add_argument("-I", "--disable-advanced-interface", dest="disable_interface", 
                        action="store_true",
                        help="""When used, log messages are redirected to the standard output. It disable color based interface.""")
 
    args = parser.parse_args()
    
    # Start the application
    app_wrapper(main, args)
